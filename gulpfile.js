'use strict';

// Native dependencies
var path        = require('path');
var exec        = require('child_process').exec;

// External dependencies
var gulp        = require('gulp');
var browserSync = require('browser-sync');
var runSequence = require('run-sequence');
var through2    = require('through2');
var del         = require('del');
var watchify    = require('watchify');
var browserify  = require('browserify');
var vinylSource = require('vinyl-source-stream');
var vinylBuffer = require('vinyl-buffer');
var _           = require('lodash');

// Load all installed gulp plugins into $
var $           = require('gulp-load-plugins')();

// Constants
var SRC_DIR     = 'src';
var DIST_DIR    = 'dist';
var MAPS_DIR    = 'source-maps';

var JS_DIR = [
    SRC_DIR + '/**/*.js',
    '!' + SRC_DIR + '/**/*.bundle.js',
    '!' + SRC_DIR + '/bower_components/**/*',
    '!' + SRC_DIR + '/sandbox/**/*',
    'gulpfile.js',
];

var LESS_DIR = [
    SRC_DIR + '/**/*.less',
    '!' + SRC_DIR + '/bower_components/**/*',
];

var CSS_DIR = [
    SRC_DIR + '/**/*.css',
    '!' + SRC_DIR + '/bower_components/**/*',
];

var HTML_DIR = [
    SRC_DIR + '/**/*.html',
    '!' + SRC_DIR + '/bower_components/**/*',
];

///////////
// build //
///////////

/**
 * Task for less.
 */
gulp.task('less', function () {

    // Message to be prepended to all .css files generated via less
    var message = [
        '/*-----------------------------------------------------',
        ' | This file was generated by LESS.                   |',
        ' | All modifications to it will be lost, mercilessly! |',
        ' -----------------------------------------------------*/\n\n',
    ].join('\n');

    return gulp.src(LESS_DIR)
        .pipe($.changed(SRC_DIR, { extension: '.css' }))
        .pipe($.duration('Compiling .less files'))
            .pipe($.sourcemaps.init())
            .pipe($.less())
            .on('error', $.notify.onError({
                title: 'Less compiling error',
                message: '<%= error.message %>',
                open: 'file:///<%= error.filename %>',
                sound: 'Glass',
                // Basso, Blow, Bottle, Frog, Funk, Glass, Hero,
                // Morse, Ping, Pop, Purr, Sosumi, Submarine, Tink
                icon: path.join(__dirname, 'logo.png'),
            }))
            .pipe($.autoprefixer({
                browsers: [
                    'ie >= 10',
                    'ie_mob >= 10',
                    'ff >= 30',
                    'chrome >= 34',
                    'safari >= 7',
                    'opera >= 23',
                    'ios >= 7',
                    'android >= 4.4',
                    'bb >= 10'
                ],
                cascade: false,
            }))
            // .pipe($.minifyCss())
            .pipe($.header(message))
        .pipe($.sourcemaps.write(MAPS_DIR))
        // Put files at source dir in order to use them for vulcanization
        .pipe(gulp.dest(SRC_DIR))
        .pipe(gulp.dest(DIST_DIR))
        .pipe($.size({ title: 'less' }));
});

/**
 * Vulcanize polymer components
 */
gulp.task('vulcanize', function () {
    return gulp.src(SRC_DIR + '/elements.html')
        .pipe($.vulcanize({
            stripComments: true,
            inlineCss: true,
            inlineScripts: true,
        }))
        .pipe(gulp.dest(DIST_DIR))
        .pipe($.size({title: 'vulcanize'}));
});

/**
 * Browserify
 */
var BROWSERIFY_OPTIONS = _.assign({}, watchify.args, {
    entries: ['./src/index.js'],
    debug: true,
    standalone: 'C',
});

/**
 * Converts a browserify stream into a gulp friendly vinyl stream
 */
function vinylifyBrowserify(b) {
    return b.bundle()
        // log errors if they happen
        .on('error', $.util.log.bind($.util, 'Browserify Error'))
        .pipe(vinylSource('index.bundle.js'))
        // optional, remove if you don't need to buffer file contents
        .pipe(vinylBuffer());
}

/**
 * Runs the browserify task once
 */
gulp.task('distribute:browserify', function () {
    return vinylifyBrowserify(browserify(BROWSERIFY_OPTIONS))
        // optional, remove if you dont want sourcemaps
        .pipe($.sourcemaps.init({ loadMaps: true })) // loads map from browserify file
            // uglify
            .pipe($.uglify({ preserveComments: 'license' }))
            // calculate size before writing source maps
            .pipe($.size({ title: 'browserify dist' }))
        // Add transformation tasks to the pipeline here.
        .pipe($.sourcemaps.write(MAPS_DIR)) // writes .map file
        .pipe(gulp.dest(DIST_DIR));
});

// Distribute
gulp.task('distribute', ['vulcanize', 'distribute:browserify'], function () {

    // Other assets
    var copyFrom = [
        'index.css',
        'index.html',
        'sandbox/base-polymer-project/**/*',
    ].map(function (f) {
        return path.join(SRC_DIR, f);
    });

    gulp.src(copyFrom, { base: SRC_DIR })
        .pipe(gulp.dest(DIST_DIR));
});

///////////
// build //
///////////

/////////////
// backend //
/////////////

// Starts the mock server
gulp.task('backend', function () {

    // var mockServerModulePath = path.join(__dirname, 'node_modules/carbono-mocks');

    // // Consign uses `process.cwd()`, which fucks stuff up.
    // // `cd` into the dir before starting module up
    // exec('cd ' + mockServerModulePath + ' && node .', function (err, stdout, stderr) {

    //     if (!err) {
    //         // No error on mock server
    //         $.util.log($.util.colors.green('mock server running'));
    //         $.util.log($.util.colors.green(stdout));
    //     } else {
    //         // Error on mock server startup
    //         $.util.log($.util.colors.red('mock server startup problems'));
    //         $.util.log($.util.colors.red(stderr));
    //     }
    // });
});

/////////////
// backend //
/////////////

/////////////////
// development //
/////////////////

/**
 * Compiles todos throughout the source code
 */
gulp.task('todo', function () {
    return gulp.src(JS_DIR.concat(LESS_DIR).concat(HTML_DIR))
        .pipe($.todo({
            reporter: 'markdown',
        }))
        .pipe(gulp.dest(''));
});

/**
 * Serves the application client
 */
gulp.task('serve', function () {

    browserSync({
        port: 4000,
        server: {
            baseDir: 'src',
        },
        open: true,
        // tunnel: true
    });
});

/**
 * Serves the application client
 */
gulp.task('serve:dist', function () {

    browserSync({
        port: 4000,
        server: {
            baseDir: 'dist',
        },
        open: true,
        // tunnel: true
    });
});

/**
 * Watches files for changes and acts accordingly
 */
gulp.task('watch', function () {
    // JS 
    gulp.watch(JS_DIR, ['jshint', 'jscs']);

    // Instantiate watchify
    var w = watchify(browserify(BROWSERIFY_OPTIONS));

    // gulp.task('browserify', bundle); // so you can run `gulp js` to build the file
    w.on('update', watchifyBundle); // on any dep update, runs the bundler
    w.on('log', $.util.log); // output build logs to terminal

    /**
     * Bundles browserify stack using watchify
     */
    function watchifyBundle() {
        return vinylifyBrowserify(w)
            // optional, remove if you dont want sourcemaps
            .pipe($.sourcemaps.init({ loadMaps: true })) // loads map from browserify file
                .on('end', browserSync.reload)
            .pipe($.sourcemaps.write(MAPS_DIR)) // writes .map file
            .pipe(gulp.dest(SRC_DIR))
            .pipe($.size({ title: 'browserify' }));
    }

    // HTML & web-components
    gulp.watch(HTML_DIR, ['jshint', 'jscs'])
        .on('change', browserSync.reload);

    // LESS
    gulp.watch(LESS_DIR, ['less'])
        .on('change', function (event) {
            if (event.type === 'deleted') {

                var p = path.parse(event.path);
                var css = p.dir + '/' + p.name + '.css';

                // Remove css file
                del(css);
            }
        });
    gulp.watch(CSS_DIR)
        .on('change', browserSync.reload);

    // Invoke watchify bundle once to start watching files
    // and return the stream in order to prevent subsequent
    // tasks from continuing without the browserify being complete
    // (crappish gulp+browserify+watchify integration)
    return watchifyBundle();
});

/**
 * Runs all tasks for development environment setup and go
 */
gulp.task('develop', function (done) {
    // First compile less, run backend and watch 
    // then serve.
    runSequence(['less', 'backend', 'watch'], 'serve', done);
});

/////////////////
// development //
/////////////////

//////////////////
// code quality //
//////////////////

/**
 * Runs jshint against the code from scripts and webcomponents
 */
gulp.task('jshint', function () {

    var reporter = through2.obj(
        function (file, encoding, cb) {

            if (!file.jshint.success) {

                var err = new $.util.PluginError('jshint', {
                    message: 'JSHint failed at ' + file.path
                });

                // Store the path for later usage 
                err.path = file.path;

                // store errrors
                this.errors = this.errors || [];
                this.errors.push(err);
            }

            // continue stream
            cb(null, file);

        }, 
        function (cb) {

            if (this.errors && this.errors.length > 0) {
                cb(this.errors.pop());
            } else {
                $.util.log($.util.colors.green('JSHint passed with success :)'));
            }
        }
    );

    return gulp.src(JS_DIR.concat(HTML_DIR))
        .pipe($.jshint.extract('auto'))
        .pipe($.jshint('.jshintrc'))
        .pipe($.jshint.reporter(require('jshint-stylish')))
        .pipe(reporter)
        .on('error', $.notify.onError({
            title: 'JSHint check error',
            message: '<%= error.message %>',
            open: 'file:///<%= error.path %>',
            sound: 'Glass',
            // Basso, Blow, Bottle, Frog, Funk, Glass, Hero,
            // Morse, Ping, Pop, Purr, Sosumi, Submarine, Tink
            icon: path.join(__dirname, 'logo.png'),
        }));
});

/**
 * Runs jscs against scripts. Todo: extract js from web componetns as well.
 */
gulp.task('jscs', function () {

    gulp.src(JS_DIR)
        .pipe($.jscs({
            configPath: '.jscsrc',
            // fix: true
        }))
        .on('error', $.notify.onError({
            title: 'JSCS style check error',
            message: '<%= error.message %>',
            open: 'file:///<%= error.filename %>',
            sound: 'Glass',
            // Basso, Blow, Bottle, Frog, Funk, Glass, Hero,
            // Morse, Ping, Pop, Purr, Sosumi, Submarine, Tink
            icon: path.join(__dirname, 'logo.png'),
        }));
});

//////////////////
// code quality //
//////////////////
